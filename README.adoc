[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/b74Fzo1b)
= Jeu de cartes Zheng Fen

.Composition du groupe (√† compl√©ter)
--
* Abi, Mohamed, 22408077, uvsq22408077
* BOUAGADA, Youcef, 22407770, uvsq22407770
* NOUMI, Mahdi, 22404628, uvsq22404628
* SRAIRI, Aissa Wail, 22406233, uvsq24406233
--

L'objet de ce mini-projet est de d√©velopper le jeu de carte https://boardgamegeek.com/boardgame/70451/zheng-fen[zheng-fen] qui doit fonctionner en mode ligne de commande.
La r√®gle du jeu est disponible dans la https://boardgamegeek.com/filepage/205610/regles-en-francais-plus-aide-de-jeu[section _Files_] du site pr√©c√©dent.
Cette derni√®re est une traduction fran√ßaise de la page https://www.pagat.com/climbing/zhengfen.html[Zheng Fen (Êå£ÂàÜ)].
Ce jeu comporte de nombreuses variantes (https://www.pagat.com/climbing/doudizhu.html[Dou Dizhu (ÊñóÂú∞‰∏ª)], https://boardgamegeek.com/boardgame/215/tichu[Tichu]).

[IMPORTANT]
====
* **L'objectif de ce projet est de travailler la conception objet**. Donc, plus que les fonctionnalit√©s, vous pr√™terez une attention particuli√®re aux choix de conception qui devront √™tre argument√©s.
* Vous devrez respecter les contraintes techniques et fonctionnelles mentionn√©es ci-dessous.
* L'usage de biblioth√®ques tierces est autoris√©.
* Ce qui n'est pas impos√© par le sujet est laiss√© √† votre libre interpr√©tation.
====

== Contraintes techniques
* Ce mini-projet est √† r√©aliser en Java par groupe de 4 √©tudiants (3 ou 5 possibles avec accord de l'enseignant).
  - les √©tudiants doivent coop√©rer √† travers un m√™me git (celui cr√©√© par _github classroom_).
  Les contributions des participants (_commits_) doivent √™tre √©quilibr√©es.
* Il devra comporter une documentation dans ce fichier (cf. ci-dessous).
  - La documentation devra d√©crire l'usage de l'application (_manuel utilisateur_) ainsi que la conception du jeu (_manuel technique_).
    En particulier, les choix de conception devront √™tre document√©s.
* Vous utiliserez `git` en effectuant des commits r√©guliers d√©crits par des messages informatifs.
L'usage des branches est √©galement exig√©, attestant ainsi de votre collaboration au sein du groupe.
La version finale de votre projet devra se trouver dans la branche `main`.
* La version de Java √† utiliser est la https://adoptium.net/[version 17] (ou plus r√©cente).
* Le _build_ sera assur√© par _Maven_ et plus pr√©cis√©ment _Maven wrapper_ (d√©j√† int√©gr√© dans le projet).
Aucune manipulation en dehors de Maven ne devra √™tre n√©cessaire pour la compilation.
* Le projet devra respecter les r√®gles de codage Google (v√©rification par `checkstyle` d√©j√† int√©gr√© dans le projet).
* Des tests unitaires https://junit.org/junit5/docs/current/user-guide/[JUnit 5] devront √™tre disponibles pour une part significative des m√©thodes d√©velopp√©es.
* Un outil de https://fr.wikipedia.org/wiki/Couverture_de_code[_Code Coverage_] devra √™tre int√©gr√© au _build_
* Les fonctionnalit√©s du langage Java devront √™tre utilis√©es au mieux (POO, exceptions, librairie de collections, I/O, ‚Ä¶).
* L'application devra pouvoir √™tre ex√©cut√©e √† partir d'un `jar` incluant toutes les d√©pendances.
* L'application fonctionnera dans un terminal (pas d'interface graphique).

== Description fonctionnelle
L'application doit permettre de jouer de 0 √† 4 joueurs humains, i.e. de z√©ro √† quatre adversaires virtuels d√©nomm√©s dans la suite _Joueurs Virtuels_ (**JV**).
Chaque JV joue grace √† un _Moteur de Jeu_ (**MJ**) mod√©lis√© par une classe de votre programme.
Un MJ peut appliquer une strat√©gie basique, ou bien jouer √† l'aide de strat√©gies plus sophistiqu√©es.
Bien entendu, l'application doit g√©rer l'encha√Ænement des manches{empty}footnote:[Une manche se termine quand il ne reste des cartes qu'√† un seul joueur (cf. la r√®gle du jeu).] et les d√©comptes des points jusqu'√† la fin du jeu{empty}footnote:[Le jeu se termine lorsqu'un joueur atteint ou d√©passe un certain nombre de points (500 en g√©n√©ral).].

=== Interface de l'application
L'interface textuelle devra

* visualiser les actions de chaque joueur par des messages textuels clairs et concis (par exemple, "JV1: üÇÆ, üÇæ, üÉé, üÉà, üÉò" ou "JV1: K(SHD), 8(DC)").
  - o√π les valeurs et les couleurs des cartes sont donn√©es par leurs initiales en anglais (**K**ing = roi, **Q**ueen = dame, **J**ack = valet, **S**pade = pique, **H**eart = c≈ìur, **D**iamond = carreau et **C**lub = tr√®fle).
* afficher chaque joueur et ses messages dans une couleur distincte.
* valider les saisies des joueurs humains
  - pour saisir une combinaison, le joueur utilisera une syntaxe du type `<Valeur>(<couleur1><couleur2>)` (par exemple "K(SHD), Q(DC)").
* afficher le nombre de cartes de chaque joueur, mais pas les valeurs de ses cartes (sauf en mode d√©bogage).
* toujours afficher les cartes ordonn√©es du plus fort au plus faible et pique (_Spade_) avant c≈ìur (_Heart_) avant carreau (_Diamond_) avant tr√®fle (_Club_).
* afficher un message clair pour les actions effectu√©es par l'application.

=== Contraintes √† respecter
* Un joueur peu d√©cider d'abandonner. 
C'est un √©v√©nement rare (surtout chez les JV), mais possible.
* L'historique d'une partie sera m√©moris√©e dans une collection stock√©e dans un fichier.
  - il sera donc possible de rejouer une partie ou d'afficher le d√©roul√© d'une partie
* Vous devez impl√©menter un MJ appliquant une strat√©gie triviale.
Le MJ se d√©barrasse de ses cartes au fur et √† mesure sans aucun assemblage.
* Vous devez √©galement impl√©menter au moins un MJ qui joue de mani√®re plus sophistiqu√©e.
* Un mode d√©bogage permettra de jouer √† jeux ouverts.
* Le MJ associ√© √† chaque JV doit pouvoir √™tre modifi√©.
* Une interface de configuration permettra de modifier les param√®tres du jeu (variantes, nombre de points pour gagner, MJ √† utiliser, ‚Ä¶)

== R√©f√©rences
* https://github.com/lyudaio/jcards[jCards] - A Lightweight Java Library for manipulating Playing Cards
* http://fusesource.github.io/jansi/[JAnsi] - Gestion des couleur dans un terminal
* https://github.com/jline/jline3[JLine] - Gestion des saisies

## Manuel utilisateur (√† compl√©ter)

### Configurer et d√©marrer une partie
1. **Configuration** :
   - Saisir le nombre de joueurs (entre 2 et 4).
   - Fournir le nom et la couleur du joueur principal.
   - Activer ou d√©sactiver le mode espionnage.
2. **D√©marrage** :
   - Lancer la commande `InitialiserLeJeuCommande` pour cr√©er une instance de la partie.
   - La partie d√©marre avec la m√©thode `GameRoundManager.demarrer()`.

### Syntaxe pour jouer une combinaison de cartes
- **Jouer une combinaison** : `combo <index>`  
  Exemple : `combo 1`
- **Jouer des cartes sp√©cifiques** : `carte <indices>`  
  Exemple : `carte 1,2,3`
- **Passer son tour** : `passe`

### Autres actions disponibles
- **Espionner** : `espionner` (si le mode espionnage est activ√©).
- **Quitter la partie** : `quitter`.

### Strat√©gies des MJ
- **MoteurBasique** : Joue la combinaison valide la plus faible qui bat la derni√®re combinaison jou√©e.
- **MoteurSophistique** : Analyse toutes les combinaisons valides et choisit la meilleure en fonction du contexte.

### √âvolutions possibles
- Ajouter des strat√©gies avanc√©es pour les MJ, comme une strat√©gie bas√©e sur l'anticipation des coups adverses.
- Int√©grer un mode multijoueur en ligne.
- Ajouter une interface graphique pour am√©liorer l'exp√©rience utilisateur.
- Enregistrer des statistiques de jeu (victoires, combinaisons jou√©es, etc.).

== Manuel technique

=== Compiler le projet

.Sous Linux
----
$ JAVA_HOME=/usr/lib/jvm/java-21-openjdk-amd64/ ./mvnw package
----

.Sous Windows
----
> mvn clean package
----

=== Ex√©cuter l'application
----
$ java -jar target/zhengfen-1.0.jar
----

=== Consulter le rapport de couverture de code
1. Ex√©cuter les tests :
----
> mvn test
----
2. G√©n√©rer le rapport :
----
> mvn jacoco:report
----
3. Ouvrir le fichier HTML dans le dossier `target/site/jacoco`.

=== Biblioth√®ques utilis√©es
- **JUnit** : Tests unitaires.
- **Mockito** : Objets simul√©s.
- **JaCoCo** : Couverture de code.
- **Jansi** : Texte color√© dans la console.
- **Maven** : Gestion des d√©pendances.

=== R√¥le des diff√©rentes classes
- **Partie** : G√®re les informations globales de la partie.
- **GameRoundManager** : G√®re les tours de jeu.
- **JoueurHumain** et **JoueurVirtuel** : Repr√©sentent les joueurs humains et virtuels.
- **MoteurBasique** et **MoteurSophistique** : Impl√©mentent les strat√©gies des MJ.
- **GenerateurCombinaisons** : G√©n√®re les combinaisons possibles √† partir d'une main.
- **ValidationStrategyFactory** : Valide les combinaisons en utilisant diff√©rentes strat√©gies.

=== Choix de conception
- **Factory Pattern** : Gestion des strat√©gies de validation.
- **Builder Pattern** : Construction des objets `Carte` et `Joueur`.
- **Open/Closed Principle** : Ajout de nouvelles r√®gles sans modifier le code existant.
- **Command Pattern** : Initialisation de la partie via des commandes sp√©cifiques.

=== Traitement des commandes utilisateur
1. **Saisie** : L'utilisateur entre une commande (ex. : `combo 1`).
2. **Analyse** : La commande est analys√©e pour d√©terminer l'action √† effectuer.
3. **Ex√©cution** : L'action correspondante est ex√©cut√©e.

.Exemple
----
Commande : `carte 1,2,3`  
- Les indices sont extraits et valid√©s avant de jouer les cartes.
----

=== Am√©liorations possibles
- Ajouter des tests pour couvrir les cas limites.
- Optimiser les algorithmes de g√©n√©ration et de validation des combinaisons.
- Ajouter des logs pour faciliter le d√©bogage.
- Int√©grer un syst√®me de sauvegarde/restauration des parties.


--
